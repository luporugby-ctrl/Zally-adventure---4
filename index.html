<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zally's Data Flow: The Pipe Mania Challenge</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #202028;
            --grid-bg: #000000;
            --pipe-color: #7f8c8d; /* Grigio industriale */
            --pipe-border: #2c3e50;
            --water-color: #00bcd4; /* Ciano brillante arcade */
            --rust-color: #e74c3c; /* Rosso ruggine */
            --zalando-orange: #ff6900;
            --gemini-blue: #4285f4;
            --text-shadow: 2px 2px 0px #000;
        }

        body {
            background-color: var(--bg-color);
            color: white;
            font-family: 'Press Start 2P', cursive; /* FONT ARCADE */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
            padding-top: 20px;
        }

        /* --- HEADER UI (HUD) --- */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 800px;
            margin-bottom: 20px;
            border-bottom: 4px solid white;
            padding-bottom: 10px;
        }

        .player-card {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .avatar-frame {
            width: 64px;
            height: 64px;
            border: 4px solid var(--zalando-orange);
            background: #000;
            padding: 2px;
            box-shadow: 4px 4px 0px #000;
        }

        .zally-avatar {
            width: 100%;
            height: 100%;
            object-fit: cover;
            image-rendering: pixelated; /* Renderizza i pixel nitidi */
        }

        .player-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .game-title {
            text-align: center;
            color: var(--zalando-orange);
            font-size: 16px;
            line-height: 1.5;
            text-shadow: var(--text-shadow);
            border: 4px solid #fff;
            padding: 10px;
            background: #000;
            box-shadow: 4px 4px 0px rgba(0,0,0,0.5);
        }

        .status-panel {
            text-align: right;
            font-size: 10px;
            color: #aaa;
        }

        /* --- GAME GRID --- */
        #game-board {
            display: grid;
            /* 8 colonne x 6 righe = 48 celle */
            grid-template-columns: repeat(8, 80px); 
            grid-template-rows: repeat(6, 80px);
            gap: 0;
            background: var(--grid-bg);
            border: 8px solid #555;
            box-shadow: 10px 10px 0px #000;
            position: relative;
        }

        /* --- TILE & PIPES (Arcade Style) --- */
        .tile {
            width: 80px;
            height: 80px;
            position: relative;
            box-sizing: border-box;
            border: 1px solid #111; /* Griglia sottile */
        }

        /* Il Tubo Base */
        .pipe-sprite {
            position: absolute;
            background: var(--pipe-color);
            border: 4px solid var(--pipe-border);
            z-index: 1;
        }

        /* Il "Joint" centrale */
        .center-joint {
            position: absolute;
            top: 25px; left: 25px;
            width: 30px; height: 30px;
            background: var(--pipe-color);
            border: 4px solid var(--pipe-border);
            z-index: 2;
        }

        /* Bracci del tubo */
        .arm-n { top: 0; left: 25px; width: 30px; height: 30px; border-bottom: none; }
        .arm-e { top: 25px; right: 0; width: 30px; height: 30px; border-left: none; }
        .arm-s { bottom: 0; left: 25px; width: 30px; height: 30px; border-top: none; }
        .arm-w { top: 25px; left: 0; width: 30px; height: 30px; border-right: none; }

        /* ACQUA (Riempimento) */
        .water-fill {
            position: absolute;
            background: var(--water-color);
            z-index: 3;
            transition: all 0.5s linear; /* Animazione flusso */
        }
        
        .water-center { top: 29px; left: 29px; width: 22px; height: 22px; transform: scale(0); }
        .water-n { top: 0; left: 29px; width: 22px; height: 0%; }
        .water-e { top: 29px; right: 29px; width: 0%; height: 22px; } /* Da sinistra a destra */
        .water-s { top: 29px; left: 29px; width: 22px; height: 0%; }
        .water-w { top: 29px; left: 0; width: 0%; height: 22px; }

        /* Stati Attivi dell'Acqua */
        .tile.wet .water-center { transform: scale(1); }
        .tile.wet .water-n { height: 35px; }
        .tile.wet .water-e { width: 55px; left: 29px; } 
        .tile.wet .water-s { height: 55px; }
        .tile.wet .water-w { width: 35px; }

        /* GLITCH (Ruggine/Rotto) */
        .tile.glitch .pipe-sprite, .tile.glitch .center-joint {
            background: var(--rust-color);
            border-color: #7e1e13;
        }
        
        .glitch-icon {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            z-index: 10;
            animation: bounce 1s infinite;
            text-shadow: 2px 2px 0 #000;
        }

        /* CURSORE ZALLY */
        #cursor {
            position: absolute;
            width: 80px; height: 80px;
            border: 4px solid var(--zalando-orange);
            background: rgba(255, 105, 0, 0.2);
            box-shadow: 0 0 15px var(--zalando-orange);
            z-index: 20;
            pointer-events: none;
            transition: transform 0.1s;
        }
        #cursor::after {
            content: "P1";
            position: absolute;
            top: -20px; left: 0;
            background: var(--zalando-orange);
            color: white;
            font-size: 10px;
            padding: 2px 5px;
        }

        /* --- POPUPS / MODALS (Retro Style) --- */
        .retro-modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: #0000aa; /* Classic Blue Screen color */
            border: 4px solid #fff;
            padding: 20px;
            width: 600px;
            display: none;
            z-index: 100;
            box-shadow: 10px 10px 0px rgba(0,0,0,0.8);
            text-align: center;
        }

        .retro-modal h2 {
            background: #fff;
            color: #0000aa;
            padding: 10px;
            margin: -20px -20px 20px -20px;
            text-transform: uppercase;
            font-size: 18px;
        }

        .retro-modal p {
            line-height: 1.8;
            margin-bottom: 20px;
            font-size: 12px;
        }

        .btn-arcade {
            background: #000;
            border: 2px solid #fff;
            color: #fff;
            padding: 15px;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            cursor: pointer;
            display: block;
            width: 100%;
            margin-bottom: 10px;
            text-align: left;
        }

        .btn-arcade:hover {
            background: var(--gemini-blue);
            color: #fff;
            border-color: #ffeb3b;
        }

        .controls-hint {
            margin-top: 20px;
            font-size: 10px;
            color: #888;
            text-align: center;
        }

        @keyframes bounce { 0%, 100% { transform: translate(-50%, -50%); } 50% { transform: translate(-50%, -60%); } }

    </style>
</head>
<body>

    <!-- HEADER -->
    <header class="game-header">
        <div class="player-card">
            <div class="avatar-frame">
                <!-- IMMAGINE ZALLY CARICATA DALL'UTENTE -->
                <img src="zally-water.jpg" class="zally-avatar" alt="Zally" onerror="this.src='https://via.placeholder.com/64/ff6900/ffffff?text=Z'">
            </div>
            <div class="player-info">
                <span style="color:var(--zalando-orange); font-size:12px;">ZALLY OPS</span>
                <span style="font-size:10px;">LVL: CHAMPION</span>
            </div>
        </div>

        <div class="game-title">
            ZALLY'S DATA FLOW<br>
            <span style="font-size:10px; color:#fff;">THE PIPE MANIA CHALLENGE</span>
        </div>

        <div class="status-panel">
            FLOW STATUS: <span id="flow-status" style="color:red">OFFLINE</span><br>
            PIPES FIXED: <span id="fixed-count">0</span>/4
        </div>
    </header>

    <!-- GRID -->
    <div id="game-board">
        <div id="cursor"></div>
        <!-- Celle generate via JS -->
    </div>

    <div class="controls-hint">
        [FRECCE] MUOVI &nbsp;&nbsp; [SPAZIO] RUOTA &nbsp;&nbsp; [INVIO] GEMINI &nbsp;&nbsp; [F] APRI RUBINETTO
    </div>

    <!-- START MODAL -->
    <div id="modal-start" class="retro-modal" style="display:block;">
        <h2>MISSIONE OPS</h2>
        <p>
            Benvenuto Zally.<br><br>
            La pipeline dei dati è compromessa in 4 punti critici.<br>
            Il report finale non può essere generato.<br><br>
            Usa <strong>GEMINI</strong> per riparare i blocchi e ripristinare il flusso.
        </p>
        <button class="btn-arcade" style="text-align:center" onclick="startGame()">>>> INIZIA TURNO <<<</button>
    </div>

    <!-- QUIZ MODAL -->
    <div id="modal-quiz" class="retro-modal">
        <h2 id="quiz-title">TITOLO SFIDA</h2>
        <p id="quiz-desc">Descrizione problema...</p>
        <div id="quiz-options">
            <!-- Bottoni generati dinamicamente -->
        </div>
    </div>

    <!-- WIN MODAL -->
    <div id="modal-win" class="retro-modal">
        <h2 style="color:#0000aa; background:#4caf50;">MISSIONE COMPIUTA</h2>
        <p>
            ECCELLENTE!<br><br>
            Hai usato Gemini per:<br>
            1. Pulire i dati<br>
            2. Generare Formule<br>
            3. Incrociare i Dati<br>
            4. Creare Grafici<br><br>
            Il Report è pronto per il Management.
        </p>
        <button class="btn-arcade" style="text-align:center" onclick="location.reload()">GIOCA ANCORA</button>
    </div>

<script>
    // --- CONFIGURAZIONE GRIGLIA ---
    const COLS = 8;
    const ROWS = 6;
    
    // TIPI DI TUBO (Bitmask: N=1, E=2, S=4, W=8)
    // Usiamo array [N, E, S, W] per facilità di lettura nel codice
    const TYPES = {
        EMPTY: [0,0,0,0],
        I: [1,0,1,0], // Verticale
        H: [0,1,0,1], // Orizzontale
        L_NE: [1,1,0,0],
        L_ES: [0,1,1,0],
        L_SW: [0,0,1,1],
        L_WN: [1,0,0,1],
        T_NES: [1,1,1,0],
        CROSS: [1,1,1,1],
        START: [0,1,0,0], // Solo Est
        END: [0,0,0,1]    // Solo Ovest
    };

    // --- MAPPA UNICA (SNAKE PATH) ---
    // S = Start, E = End, 0 = Empty
    // 1 = I, 2 = H, 3 = L (Curva), 4 = T, 9 = Glitch (Broken)
    
    // Coordinate Glitch (fisse nel codice per semplicità)
    // Glitch 1: (2,1) - Cleaning
    // Glitch 2: (5,2) - Formula
    // Glitch 3: (2,4) - Logic
    // Glitch 4: (6,4) - Chart
    
    // Mappa logica per il rendering iniziale (semplificata)
    // S -> -- -> G1 -> -- |
    //                     |
    //      -- <- G2 <- -- |
    //      |
    //      -> G3 -> -- -> -- -> G4 -> E
    
    // Definizione manuale della griglia per assicurare il percorso
    let initialMap = [
        ['S', 'H', 'G1', 'L_SW',  0,    0,    0,    0],
        [ 0,   0,   0,   'I',     0,    0,    0,    0],
        [ 0,   0,   0,   'L_WN', 'G2', 'L_SW',  0,    0],
        [ 0,   0,   0,    0,      0,   'I',     0,    0],
        [ 0,  'G3', 'H', 'H',    'H',  'L_WN', 'G4', 'E'],
        [ 0,   0,    0,   0,      0,    0,      0,    0]
    ];

    // DB DELLE SFIDE
    const GLITCHES = {
        'G1': {
            title: "DATA CLEANING",
            desc: "I dati sono arrivati sporchi! Formati data misti (USA/EU) bloccano il flusso.",
            correct: "Usa Smart Fill: 'Correggi date in DD/MM/YYYY'",
            opts: ["Scrivi a mano 500 righe", "Usa Smart Fill: 'Correggi date'", "Cancella le righe errate"],
            fixedType: 'H' // Diventa orizzontale
        },
        'G2': {
            title: "FORMULA MANCANTE",
            desc: "Perdita nel tubo! Manca il calcolo dell'IVA per la Germania.",
            correct: "Prompt: 'Calcola 19% se Nazione è DE'",
            opts: ["Cerca formula su Google", "Prompt: 'Calcola 19% se Nazione è DE'", "Usa Calcolatrice"],
            fixedType: 'H' // Diventa orizzontale
        },
        'G3': {
            title: "CROSS REFERENCING",
            desc: "Valvola bloccata. Devi unire i dati dei Resi con quelli delle Vendite.",
            correct: "Prompt: 'Cerca Status Reso dal Foglio 2'",
            opts: ["Copia-Incolla manuale", "VLOOKUP a memoria", "Prompt: 'Cerca Status Reso dal Foglio 2'"],
            fixedType: 'H' // Diventa orizzontale
        },
        'G4': {
            title: "VISUALIZATION",
            desc: "Pressione alta! Il Management vuole un grafico immediato delle performance.",
            correct: "Prompt: 'Crea Grafico a barre Vendite'",
            opts: ["Disegna su carta", "Prompt: 'Crea Grafico a barre Vendite'", "Esporta in Paint"],
            fixedType: 'H' // Diventa orizzontale
        }
    };

    // STATO GIOCO
    let grid = [];
    let zally = {x:0, y:0};
    let fixedCount = 0;
    let isPaused = true;

    function startGame() {
        document.getElementById('modal-start').style.display = 'none';
        initGrid();
        isPaused = false;
        zally = {x:0, y:0};
        moveCursor();
    }

    function initGrid() {
        const board = document.getElementById('game-board');
        // Mantieni il cursore
        const cursor = document.getElementById('cursor');
        board.innerHTML = ''; 
        board.appendChild(cursor);

        grid = [];

        for(let y=0; y<ROWS; y++) {
            let row = [];
            for(let x=0; x<COLS; x++) {
                let code = initialMap[y][x] || 0;
                let tileData = {
                    x, y,
                    code: code,
                    conns: [0,0,0,0],
                    isGlitch: false,
                    isFixed: true,
                    element: null
                };

                // Parsing Mappa
                if(code === 'S') tileData.conns = [...TYPES.START];
                else if(code === 'E') tileData.conns = [...TYPES.END];
                else if(code === 'I') tileData.conns = [...TYPES.I];
                else if(code === 'H') tileData.conns = [...TYPES.H];
                else if(code === 'L_NE') tileData.conns = [...TYPES.L_NE];
                else if(code === 'L_ES') tileData.conns = [...TYPES.L_ES];
                else if(code === 'L_SW') tileData.conns = [...TYPES.L_SW];
                else if(code === 'L_WN') tileData.conns = [...TYPES.L_WN];
                else if(String(code).startsWith('G')) {
                    tileData.isGlitch = true;
                    tileData.isFixed = false;
                    tileData.conns = [0,0,0,0]; // Rotto, non passa
                }

                // Random rotazione per tubi normali (per renderlo un gioco)
                // Se non è start, end, o glitch
                if(!['S','E'].includes(code) && !tileData.isGlitch && code !== 0) {
                     // Ruotiamo a caso per far giocare l'utente
                     let r = Math.floor(Math.random()*4);
                     for(let i=0; i<r; i++) rotateConns(tileData);
                }

                createTileDOM(tileData, board);
                row.push(tileData);
            }
            grid.push(row);
        }
    }

    function createTileDOM(tile, container) {
        let el = document.createElement('div');
        el.className = 'tile';
        if(tile.isGlitch) el.classList.add('glitch');

        // Sprite HTML Construction
        let html = '';
        
        // Se c'è un tubo
        if(tile.code !== 0) {
            html += `<div class="center-joint"></div>
                     <div class="water-fill water-center"></div>`;
            
            // Bracci
            ['n','e','s','w'].forEach(dir => {
                html += `<div class="pipe-sprite arm-${dir}" id="arm-${dir}-${tile.x}-${tile.y}" style="display:none"></div>
                         <div class="water-fill water-${dir}" id="water-${dir}-${tile.x}-${tile.y}"></div>`;
            });

            if(tile.code === 'S') html += `<div style="position:absolute; top:5px; left:5px; color:#4caf50; font-size:10px;">IN</div>`;
            if(tile.code === 'E') html += `<div style="position:absolute; top:5px; right:5px; color:#ffeb3b; font-size:10px;">OUT</div>`;
            
            if(tile.isGlitch) html += `<div class="glitch-icon">⚠️</div>`;
        }

        el.innerHTML = html;
        container.appendChild(el);
        tile.element = el;
        updateVisuals(tile);
    }

    function rotateConns(tile) {
        // [N,E,S,W] -> [W,N,E,S]
        tile.conns.unshift(tile.conns.pop());
    }

    function updateVisuals(tile) {
        if(tile.code === 0) return;
        const c = tile.conns;
        const e = tile.element;
        
        // Mostra/Nascondi bracci in base alle connessioni logiche
        e.querySelector(`#arm-n-${tile.x}-${tile.y}`).style.display = c[0] ? 'block' : 'none';
        e.querySelector(`#arm-e-${tile.x}-${tile.y}`).style.display = c[1] ? 'block' : 'none';
        e.querySelector(`#arm-s-${tile.x}-${tile.y}`).style.display = c[2] ? 'block' : 'none';
        e.querySelector(`#arm-w-${tile.x}-${tile.y}`).style.display = c[3] ? 'block' : 'none';

        if(!tile.isGlitch && e.classList.contains('glitch')) {
            e.classList.remove('glitch');
            e.querySelector('.glitch-icon').remove();
        }
    }

    // --- INPUT ---
    document.addEventListener('keydown', (e) => {
        if(isPaused) return;

        if(e.key === 'ArrowUp' && zally.y > 0) zally.y--;
        if(e.key === 'ArrowDown' && zally.y < ROWS-1) zally.y++;
        if(e.key === 'ArrowLeft' && zally.x > 0) zally.x--;
        if(e.key === 'ArrowRight' && zally.x < COLS-1) zally.x++;
        
        moveCursor();

        if(e.key === ' ' || e.code === 'Space') {
            let t = grid[zally.y][zally.x];
            if(t.code !== 0 && !t.isGlitch && t.code !== 'S' && t.code !== 'E') {
                rotateConns(t);
                updateVisuals(t);
            }
        }

        if(e.key === 'Enter') {
            let t = grid[zally.y][zally.x];
            if(t.isGlitch) launchQuiz(t);
        }

        if(e.key === 'f' || e.key === 'F') checkFlow();
    });

    function moveCursor() {
        const c = document.getElementById('cursor');
        c.style.transform = `translate(${zally.x * 80}px, ${zally.y * 80}px)`;
    }

    // --- GEMINI QUIZ ---
    function launchQuiz(tile) {
        isPaused = true;
        const data = GLITCHES[tile.code];
        
        document.getElementById('quiz-title').innerText = data.title;
        document.getElementById('quiz-desc').innerText = data.desc;
        
        const optsDiv = document.getElementById('quiz-options');
        optsDiv.innerHTML = '';
        
        data.opts.forEach(opt => {
            let btn = document.createElement('button');
            btn.className = 'btn-arcade';
            btn.innerText = "> " + opt;
            btn.onclick = () => resolveQuiz(opt === data.correct, tile);
            optsDiv.appendChild(btn);
        });

        document.getElementById('modal-quiz').style.display = 'block';
    }

    function resolveQuiz(success, tile) {
        document.getElementById('modal-quiz').style.display = 'none';
        isPaused = false;
        
        if(success) {
            // Ripara tubo
            tile.isGlitch = false;
            tile.isFixed = true;
            // Assegna forma corretta (hardcoded per semplificare il flow)
            // G1, G2, G3, G4 sono tutti orizzontali nel design della mappa
            tile.conns = [...TYPES[GLITCHES[tile.code].fixedType]]; 
            
            fixedCount++;
            document.getElementById('fixed-count').innerText = fixedCount;
            updateVisuals(tile);
            
            // Effetto sonoro mentale "ding"
        } else {
            alert("Risposta errata. Gemini non ha capito il prompt. Riprova!");
        }
    }

    // --- FLOW LOGIC (DFS/BFS) ---
    function checkFlow() {
        // Reset visuale acqua
        document.querySelectorAll('.tile').forEach(t => t.classList.remove('wet'));
        
        document.getElementById('flow-status').innerText = "PUMPING...";
        document.getElementById('flow-status').style.color = "#ffeb3b";

        let queue = [{x:0, y:0}]; // Start è a 0,0
        let visited = new Set(['0,0']);
        let endReached = false;
        
        // Attiva start
        let startTile = grid[0][0];
        startTile.element.classList.add('wet');

        let delay = 0;

        function step() {
            let nextQueue = [];
            if(queue.length === 0) return;

            queue.forEach(curr => {
                let t = grid[curr.y][curr.x];
                
                // Direzioni: N(0), E(1), S(2), W(3)
                // Offset: 
                const dirs = [
                    {dx:0, dy:-1, out:0, in:2},
                    {dx:1, dy:0,  out:1, in:3},
                    {dx:0, dy:1,  out:2, in:0},
                    {dx:-1, dy:0,  out:3, in:1}
                ];

                dirs.forEach(d => {
                    if(t.conns[d.out]) {
                        let nx = curr.x + d.dx;
                        let ny = curr.y + d.dy;
                        
                        if(nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                            let nextT = grid[ny][nx];
                            // Se accetta connessione e non è rotto
                            if(nextT.conns[d.in] && nextT.isFixed) {
                                let key = nx+','+ny;
                                if(!visited.has(key)) {
                                    visited.add(key);
                                    nextQueue.push({x:nx, y:ny});
                                    
                                    setTimeout(() => {
                                        nextT.element.classList.add('wet');
                                    }, delay * 200);

                                    if(nextT.code === 'E') endReached = true;
                                }
                            }
                        }
                    }
                });
            });

            queue = nextQueue;
            delay++;
            
            if(queue.length > 0) {
                step();
            } else {
                // Fine propagazione
                setTimeout(() => {
                    if(endReached && fixedCount === 4) {
                         document.getElementById('flow-status').innerText = "OPTIMAL";
                         document.getElementById('flow-status').style.color = "#4caf50";
                         document.getElementById('modal-win').style.display = 'block';
                    } else {
                         document.getElementById('flow-status').innerText = "LEAKING";
                         document.getElementById('flow-status').style.color = "red";
                         // Rimuovi acqua dopo 2 sec
                         setTimeout(() => {
                            document.querySelectorAll('.tile').forEach(t => t.classList.remove('wet'));
                         }, 2000);
                    }
                }, delay * 200 + 500);
            }
        }
        step();
    }

</script>
</body>
</html>
