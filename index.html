<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zally Ops: Pipe Mania 3D</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #2c3e50;
            --grid-bg: #1a252f;
            --pipe-metal: linear-gradient(90deg, #4a4a4a 0%, #999 50%, #4a4a4a 100%);
            --pipe-rust: linear-gradient(90deg, #5d4037 0%, #8d6e63 50%, #5d4037 100%);
            --water-flow: linear-gradient(90deg, #0288d1 0%, #29b6f6 50%, #0288d1 100%);
            --zalando-orange: #ff6900;
            --gemini-blue: #4285f4;
        }

        body {
            background-color: var(--bg-color);
            color: white;
            font-family: 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        /* HEADER & UI */
        .header-ui {
            display: flex;
            justify-content: space-between;
            width: 620px;
            margin-bottom: 15px;
            align-items: center;
        }

        .zally-badge {
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 50px;
            border: 2px solid var(--zalando-orange);
            transition: transform 0.2s;
        }

        .zally-badge:hover {
            transform: scale(1.05);
            background: rgba(255, 105, 0, 0.1);
        }

        .zally-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid white;
            object-fit: cover;
            background: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .level-info {
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            text-align: right;
            text-shadow: 2px 2px 0 #000;
        }

        /* GAME GRID */
        #game-board {
            display: grid;
            grid-template-columns: repeat(6, 100px); /* 6 Colonne */
            grid-template-rows: repeat(6, 100px);    /* 6 Righe */
            gap: 4px;
            background: var(--grid-bg);
            border: 8px solid #34495e;
            border-radius: 10px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            position: relative;
        }

        /* TILE (Singola cella) */
        .tile {
            width: 100px;
            height: 100px;
            position: relative;
            background: #2c3e50;
            overflow: hidden;
        }

        /* CURSORE DI ZALLY */
        .cursor {
            position: absolute;
            width: 100px;
            height: 100px;
            border: 4px solid var(--zalando-orange);
            box-sizing: border-box;
            z-index: 10;
            pointer-events: none;
            box-shadow: 0 0 20px var(--zalando-orange);
            transition: all 0.1s ease;
        }

        .cursor::after {
            content: 'ZALLY';
            position: absolute;
            bottom: -25px;
            left: 0;
            width: 100%;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--zalando-orange);
            text-shadow: 2px 2px 0 #000;
        }

        /* GLI ELEMENTI DEL TUBO (Il cuore realistico) */
        .pipe-container {
            width: 100%;
            height: 100%;
            position: relative;
            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        /* Il corpo del tubo */
        .arm {
            position: absolute;
            background: var(--pipe-metal);
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.5), 2px 2px 5px rgba(0,0,0,0.3);
            z-index: 1;
        }

        /* Il giunto centrale */
        .joint {
            position: absolute;
            top: 30px;
            left: 30px;
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, #bbb 0%, #555 100%);
            border-radius: 50%;
            z-index: 2;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
        }

        /* Posizioni dei bracci */
        .arm.north { top: 0; left: 35px; width: 30px; height: 50px; }
        .arm.east  { top: 35px; right: 0; width: 50px; height: 30px; }
        .arm.south { bottom: 0; left: 35px; width: 30px; height: 50px; }
        .arm.west  { top: 35px; left: 0; width: 50px; height: 30px; }

        /* ACQUA (Sovrapposizione che appare quando scorre) */
        .water {
            position: absolute;
            background: var(--water-flow);
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 3;
            box-shadow: 0 0 10px #00bcd4;
        }
        
        .water.active { opacity: 1; }

        /* Dimensioni acqua (leggermente più piccole del tubo) */
        .water.center { top: 35px; left: 35px; width: 30px; height: 30px; border-radius: 50%; }
        .water.north { top: 0; left: 40px; width: 20px; height: 50px; }
        .water.east  { top: 40px; right: 0; width: 50px; height: 20px; }
        .water.south { bottom: 0; left: 40px; width: 20px; height: 50px; }
        .water.west  { top: 40px; left: 0; width: 50px; height: 20px; }

        /* MODIFICATORI */
        /* Tubo Arrugginito (Glitch) */
        .tile.glitch .arm { background: var(--pipe-rust); }
        .tile.glitch .joint { background: radial-gradient(circle, #8d6e63 0%, #3e2723 100%); }
        .tile.glitch::after {
            content: '⚠️';
            position: absolute;
            top: 5px; right: 5px;
            font-size: 20px;
            z-index: 5;
            animation: pulse 1s infinite;
            text-shadow: 2px 2px 0 #000;
        }

        /* Start / End Labels */
        .tile.start::before { content: 'IN'; position: absolute; top:5px; left:5px; color:#4caf50; font-weight:bold; font-size:12px; z-index:5; text-shadow: 1px 1px 0 #000;}
        .tile.end::before { content: 'OUT'; position: absolute; bottom:5px; right:5px; color:#ffeb3b; font-weight:bold; font-size:12px; z-index:5; text-shadow: 1px 1px 0 #000;}

        /* MODALI */
        .modal {
            position: absolute;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid var(--gemini-blue);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 500px;
            display: none;
            z-index: 100;
            box-shadow: 0 0 50px rgba(66, 133, 244, 0.5);
        }

        .modal h2 { color: var(--gemini-blue); font-family: 'Press Start 2P'; margin-bottom: 20px; font-size: 16px; line-height: 1.5; }
        .modal p { line-height: 1.6; margin-bottom: 20px; color: #ddd; }
        
        .quiz-btn {
            background: #333;
            border: 1px solid #666;
            color: white;
            padding: 15px;
            width: 100%;
            margin: 5px 0;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
        }
        .quiz-btn:hover { background: var(--gemini-blue); border-color: white; }

        .key-hint {
            position: absolute;
            bottom: 20px;
            color: #888;
            font-size: 12px;
            text-transform: uppercase;
            font-family: 'Roboto', sans-serif;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }

        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

    </style>
</head>
<body>

    <!-- Header -->
    <div class="header-ui">
        <div class="zally-badge">
            <!-- IMMAGINE ZALLY INTEGRATA QUI -->
            <img src="zally-water.jpg" class="zally-avatar" alt="Zally">
            <div>
                <strong style="display:block; font-size:14px; text-transform:uppercase; letter-spacing:1px;">ZALLY OPS</strong>
                <span style="font-size:11px; color:#ccc;">Pipeline Engineer</span>
            </div>
        </div>
        <div class="level-info">
            LIVELLO <span id="lvl-num" style="color:var(--zalando-orange)">1</span><br>
            <span id="task-name" style="color:#aaa; font-size:10px; margin-top:5px; display:block;">DATA CLEANING</span>
        </div>
    </div>

    <!-- Area di Gioco -->
    <div id="game-board">
        <!-- Generato via JS -->
        <div id="cursor" class="cursor"></div>
    </div>

    <div class="key-hint">
        FRECCE: Muovi | SPAZIO: Ruota | INVIO: Gemini (Su Ruggine) | F: Apri Flusso
    </div>

    <!-- MODAL: Istruzioni Iniziali -->
    <div id="start-modal" class="modal" style="display:block;">
        <h2>PIPE MANIA: OPS EDITION</h2>
        <p>Benvenuto nei sotterranei dei dati di Zalando.</p>
        <p>Il sistema di tubature è vecchio e arrugginito. Devi connettere l'INPUT (Dati) all'OUTPUT (Report).</p>
        <p style="color:var(--zalando-orange); font-weight:bold;">Attenzione ai tubi arrugginiti! <br>Sono "Glitch" nei dati.</p>
        <p>Posizionati sopra e premi <strong style="color:white; border:1px solid white; padding:2px 5px; border-radius:3px;">INVIO</strong> per chiedere a Gemini di ripararli.</p>
        <button class="quiz-btn" onclick="startGame()" style="text-align:center; font-weight:bold; background:var(--zalando-orange); border-color:var(--zalando-orange);">INIZIA IL TURNO</button>
    </div>

    <!-- MODAL: Gemini Quiz -->
    <div id="gemini-modal" class="modal">
        <h2>✨ AIUTO GEMINI</h2>
        <p id="gemini-q">Domanda...</p>
        <div id="gemini-opts"></div>
    </div>

    <!-- MODAL: Successo -->
    <div id="win-modal" class="modal">
        <h2 style="color:#4caf50">FLUSSO STABILIZZATO!</h2>
        <p>Ottimo lavoro! I dati scorrono perfettamente.</p>
        <button class="quiz-btn" onclick="nextLevel()" style="text-align:center; background:#4caf50; border-color:#4caf50;">PROSSIMO LIVELLO ➔</button>
    </div>

<script>
    // --- CONFIGURAZIONE ---
    const COLS = 6;
    const ROWS = 6;
    
    // Tipi di tubo: [N, E, S, W] (1 = aperto)
    const PIPES = {
        STRAIGHT: [1, 0, 1, 0], // I
        ELBOW:    [1, 1, 0, 0], // L
        TEE:      [1, 1, 1, 0], // T
        CROSS:    [1, 1, 1, 1], // +
        START:    [0, 1, 0, 0], // Solo Est
        END:      [0, 0, 0, 1]  // Solo Ovest
    };

    // Scenari
    const LEVELS = [
        {
            id: 1,
            name: "DATA CLEANING",
            task: "cleaning",
            map: [ // 0=Vuoto, 1=Dritto, 2=Curva, 3=T, 4=Start, 5=End
                [4, 1, 2, 0, 0, 0],
                [0, 0, 1, 2, 1, 0],
                [0, 2, 3, 0, 2, 5],
                [0, 1, 0, 0, 1, 0],
                [0, 2, 1, 2, 3, 0],
                [0, 0, 0, 0, 0, 0]
            ],
            glitches: [{x:2, y:2}, {x:4, y:2}] // Coordinate dei tubi arrugginiti
        },
        {
            id: 2,
            name: "FORMULA GAP",
            task: "formula",
            map: [
                [4, 2, 0, 2, 1, 2],
                [0, 1, 0, 1, 0, 1],
                [0, 3, 1, 3, 0, 1],
                [0, 0, 0, 1, 0, 1],
                [0, 2, 1, 2, 0, 5],
                [0, 0, 0, 0, 0, 0]
            ],
            glitches: [{x:1, y:2}, {x:3, y:2}]
        }
    ];

    const QUIZ = {
        cleaning: {
            q: "Questo tubo è intasato da formattazioni miste (Date USA vs EU). Come lo pulisci?",
            opts: [
                {t: "Lo cambio a mano cella per cella", ok: false},
                {t: "Prompt: 'Converti tutte le date in DD/MM/YYYY'", ok: true},
                {t: "Cancello la colonna", ok: false}
            ]
        },
        formula: {
            q: "Il tubo perde! Manca una formula per calcolare l'IVA solo per la Germania.",
            opts: [
                {t: "Prompt: 'Se Nazione è DE, moltiplica per 0.19'", ok: true},
                {t: "Cerco la formula IF su Google", ok: false},
                {t: "Metto 19% ovunque", ok: false}
            ]
        }
    };

    // --- STATO ---
    let currentLvlIdx = 0;
    let grid = []; // Matrice oggetti
    let zally = {x:0, y:0};
    let isLocked = true; // Input bloccato

    // --- INIZIALIZZAZIONE ---
    function startGame() {
        document.getElementById('start-modal').style.display = 'none';
        loadLevel(0);
    }

    function loadLevel(idx) {
        if(idx >= LEVELS.length) {
            alert("Training Completato! Sei un Gemini Champion!");
            return;
        }
        currentLvlIdx = idx;
        const lvl = LEVELS[idx];
        
        document.getElementById('lvl-num').innerText = lvl.id;
        document.getElementById('task-name').innerText = lvl.name;
        
        createGrid(lvl);
        isLocked = false;
        zally = {x:0, y:0};
        updateCursor();
    }

    function createGrid(lvl) {
        const board = document.getElementById('game-board');
        // Rimuovi tutto tranne il cursore
        while(board.firstChild) { 
            if(board.firstChild.id === 'cursor') break; 
            board.removeChild(board.firstChild); 
        }
        // Riaggiungi cursore se perso (safety) o pulisci resto
        board.innerHTML = '<div id="cursor" class="cursor"></div>';
        
        grid = [];

        for(let y=0; y<ROWS; y++) {
            let row = [];
            for(let x=0; x<COLS; x++) {
                const cellType = lvl.map[y][x];
                
                // Crea Elemento DOM
                const el = document.createElement('div');
                el.className = 'tile';
                
                // Crea Struttura Dati
                let tile = {
                    x, y,
                    type: cellType, // 1=I, 2=L, 3=T
                    conns: [0,0,0,0], // N E S W
                    rotation: 0, // 0-3
                    isGlitch: false,
                    isFixed: true,
                    el: el
                };

                // Setup visivo
                if (cellType !== 0) {
                    renderPipe(tile, cellType);
                    
                    // Controlla se è un glitch
                    if (lvl.glitches.some(g => g.x === x && g.y === y)) {
                        tile.isGlitch = true;
                        tile.isFixed = false;
                        el.classList.add('glitch');
                    }
                    if (cellType === 4) el.classList.add('start');
                    if (cellType === 5) el.classList.add('end');
                    
                    // Random rotazione iniziale (tranne start/end)
                    if(cellType !== 4 && cellType !== 5) {
                         const r = Math.floor(Math.random() * 4);
                         for(let i=0; i<r; i++) rotateLogic(tile);
                    } else {
                        // Start punta a Est, End riceve da Ovest
                        if(cellType===4) tile.conns = [0,1,0,0]; 
                        if(cellType===5) tile.conns = [0,0,0,1];
                    }
                }
                
                updatePipeVisuals(tile);
                board.appendChild(el);
                row.push(tile);
            }
            grid.push(row);
        }
    }

    // --- LOGICA TUBI ---
    
    function renderPipe(tile, typeIdx) {
        // Mappa ID mappa -> Tipo Logico
        let baseConns = [0,0,0,0];
        if (typeIdx === 1) baseConns = [...PIPES.STRAIGHT];
        if (typeIdx === 2) baseConns = [...PIPES.ELBOW];
        if (typeIdx === 3) baseConns = [...PIPES.TEE];
        if (typeIdx === 4) baseConns = [...PIPES.START];
        if (typeIdx === 5) baseConns = [...PIPES.END];

        tile.conns = baseConns;

        // Costruisci HTML interno (Bracci + Giunto + Acqua)
        tile.el.innerHTML = `
            <div class="pipe-container">
                <div class="joint"></div>
                <div class="water center"></div>
                <!-- Bracci -->
                <div class="arm north" style="display:none"></div>
                <div class="water north"></div>
                
                <div class="arm east" style="display:none"></div>
                <div class="water east"></div>
                
                <div class="arm south" style="display:none"></div>
                <div class="water south"></div>
                
                <div class="arm west" style="display:none"></div>
                <div class="water west"></div>
            </div>
        `;
    }

    function rotateLogic(tile) {
        // Sposta array: [N,E,S,W] -> [W,N,E,S] (Rotazione Oraria)
        tile.conns.unshift(tile.conns.pop());
        tile.rotation = (tile.rotation + 1) % 4;
    }

    function updatePipeVisuals(tile) {
        if (tile.type === 0) return;
        
        // Invece di ruotare tutto il div, mostriamo/nascondiamo i bracci in base a .conns
        // Questo è necessario perché i bracci hanno ombre realistiche fisse
        const c = tile.conns; // [N, E, S, W]
        const pc = tile.el.querySelector('.pipe-container');
        
        // Reset display
        pc.querySelector('.arm.north').style.display = c[0] ? 'block' : 'none';
        pc.querySelector('.arm.east').style.display  = c[1] ? 'block' : 'none';
        pc.querySelector('.arm.south').style.display = c[2] ? 'block' : 'none';
        pc.querySelector('.arm.west').style.display  = c[3] ? 'block' : 'none';
        
        // Se glitch, togli la classe se fixato
        if(!tile.isGlitch && tile.el.classList.contains('glitch')) {
            tile.el.classList.remove('glitch');
            // Flash effect
            tile.el.style.filter = "brightness(1.5)";
            setTimeout(() => tile.el.style.filter = "none", 200);
        }
    }

    // --- INPUT ---
    document.addEventListener('keydown', (e) => {
        if(isLocked) return;
        
        const key = e.key;
        if(key === 'ArrowUp' && zally.y > 0) zally.y--;
        if(key === 'ArrowDown' && zally.y < ROWS-1) zally.y++;
        if(key === 'ArrowLeft' && zally.x > 0) zally.x--;
        if(key === 'ArrowRight' && zally.x < COLS-1) zally.x++;
        
        updateCursor();

        if(key === ' ') { // Space: Ruota
            const t = grid[zally.y][zally.x];
            if(t.type !== 0 && t.type !== 4 && t.type !== 5 && t.isFixed) {
                rotateLogic(t);
                updatePipeVisuals(t);
            }
        }

        if(key === 'Enter') { // Gemini
            const t = grid[zally.y][zally.x];
            if(t.isGlitch) openGemini(t);
        }

        if(key === 'f' || key === 'F') checkFlow();
    });

    function updateCursor() {
        const c = document.getElementById('cursor');
        c.style.transform = `translate(${zally.x * 104}px, ${zally.y * 104}px)`; // 100px + 4px gap
    }

    // --- GEMINI LOGIC ---
    function openGemini(tile) {
        isLocked = true;
        const lvl = LEVELS[currentLvlIdx];
        const data = QUIZ[lvl.task];
        
        document.getElementById('gemini-q').innerText = data.q;
        const opts = document.getElementById('gemini-opts');
        opts.innerHTML = '';
        
        data.opts.forEach(o => {
            const btn = document.createElement('button');
            btn.className = 'quiz-btn';
            btn.innerText = o.t;
            btn.onclick = () => {
                if(o.ok) {
                    tile.isGlitch = false;
                    tile.isFixed = true;
                    updatePipeVisuals(tile);
                    document.getElementById('gemini-modal').style.display = 'none';
                    isLocked = false;
                } else {
                    alert("Soluzione errata! Riprova.");
                }
            };
            opts.appendChild(btn);
        });
        
        document.getElementById('gemini-modal').style.display = 'block';
    }

    // --- FLOW LOGIC ---
    function checkFlow() {
        // Reset acqua
        document.querySelectorAll('.water').forEach(el => el.classList.remove('active'));
        
        // BFS per trovare il percorso
        let queue = [{x:0, y:0}];
        let visited = new Set(['0,0']);
        let endReached = false;
        
        // Attiva acqua Start
        activateWater(0,0);

        // Simulazione ritardata per effetto "scorrimento"
        let step = 0;
        
        function processQueue() {
            let nextQueue = [];
            if(queue.length === 0) return;

            queue.forEach(curr => {
                const t = grid[curr.y][curr.x];
                
                // Controlla 4 direzioni
                const dirs = [
                    {dx:0, dy:-1, outIdx:0, inIdx:2}, // N
                    {dx:1, dy:0,  outIdx:1, inIdx:3}, // E
                    {dx:0, dy:1,  outIdx:2, inIdx:0}, // S
                    {dx:-1, dy:0, outIdx:3, inIdx:1}  // W
                ];

                dirs.forEach(d => {
                    // Se tubo corrente esce in questa direzione
                    if(t.conns[d.outIdx]) {
                        const nx = curr.x + d.dx;
                        const ny = curr.y + d.dy;
                        
                        if(nx>=0 && nx<COLS && ny>=0 && ny<ROWS) {
                            const nextT = grid[ny][nx];
                            // Se vicino accetta e non è glitch
                            if(nextT.type !== 0 && !nextT.isGlitch && nextT.conns[d.inIdx]) {
                                const key = `${nx},${ny}`;
                                if(!visited.has(key)) {
                                    visited.add(key);
                                    nextQueue.push({x:nx, y:ny});
                                    setTimeout(() => activateWater(nx, ny), step * 200);
                                    if(nextT.type === 5) endReached = true;
                                }
                            }
                        }
                    }
                });
            });

            step++;
            queue = nextQueue;
            if(queue.length > 0) {
                setTimeout(processQueue, 200);
            } else {
                if(endReached) setTimeout(() => document.getElementById('win-modal').style.display='block', step*200 + 500);
            }
        }
        
        processQueue();
    }

    function activateWater(x, y) {
        const t = grid[y][x];
        const pc = t.el.querySelector('.pipe-container');
        pc.querySelectorAll('.water').forEach(w => w.classList.add('active'));
    }

    function nextLevel() {
        document.getElementById('win-modal').style.display = 'none';
        loadLevel(currentLvlIdx + 1);
    }

</script>
</body>
</html>
